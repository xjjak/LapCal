#+title: Data Collection and Preprocessing

#+property: header-args:jupyter-python :session *jupyter* :eval no-export
#+OPTIONS: ^:nil h:6

This document describes all software related to data collection, when possible in a literate programming style.

Except for the [[*A Brief Description of Our Data][first chapter]] -- a broad descrpition of how our data will look for all datasets -- and the [[*The Data Collection Process][second chapter]] -- a description of the general collection process --, the chapters are organized by dataset type. Each dataset type chapter includes all relevant
- descriptions and design choices,
- software to collect the relevant data, and
- processing capabilities to convert raw data into refined datasets.

Notably, the dataset types mostly vary by how we collect the [[*Labels][labels]].

* Contents                                                         :noexport:
:PROPERTIES:
:TOC:      :include all :ignore (this)
:END:

# TOC automattically generated by [[https://github.com/alphapapa/org-make-toc]]
# NOTE: These links will *only* work on github.
:CONTENTS:
- [[#a-brief-description-of-our-data][A Brief Description of Our Data]]
  - [[#features][Features]]
  - [[#labels][Labels]]
- [[#the-data-collection-process][The Data Collection Process]]
  - [[#csv][CSV]]
    - [[#loading-data][Loading Data]]
    - [[#write-data][Write Data]]
- [[#collecting-data][Collecting Data]]
  - [[#capturing-keypresses-directly-from-the-keyboard][Capturing Keypresses Directly from the Keyboard]]
    - [[#description][Description]]
      - [[#raw-data][Raw Data]]
      - [[#dataset][Dataset]]
    - [[#keypresses-directly-from-the-keyboard][Keypresses Directly from the Keyboard]]
    - [[#rectify-errors][Rectify Errors]]
      - [[#find-errors][Find Errors]]
      - [[#fix-errors][Fix Errors]]
    - [[#a-look-at-the-data][A Look at the Data]]
    - [[#center-the-data][Center the Data]]
      - [[#a-visual-comparison-to-the-uncentered-data][A Visual Comparison to the Uncentered Data]]
      - [[#save-data][Save Data]]
    - [[#aggregate-features-and-labels][Aggregate Features and Labels]]
      - [[#features][Features]]
        - [[#change-based-features][Change-based Features]]
        - [[#history-based-features][History-based Features]]
      - [[#labels][Labels]]
    - [[#write-dataset][Write Dataset]]
:END:

* A Brief Description of Our Data
Before we start describing the software that is used in the data collection process, we first want to give a quick overview of what our data actually consist of and where it comes from.

The data we collect can broadly be divided into two categories, since we use supervised learning:
1. The [[*Features][features]] our model takes as input. These are necessary during training and deployment of the model.
2. The [[*Labels][labels]] our model produces as output. These are only necessary during training. During deployment the model itself will produce predictions for them.

** Features
The features are generated using the hardware developed in [[file:../Hardware][other parts of the project]] in a more or less straightforward. While the specifics might change, in general the data will always come from [[https://en.wikipedia.org/wiki/Inertial_measurement_unit][inertial measurement units]] on the fingers and the back of the hand. The IMUs we currently use (MPU6050) give us information about their current acceleration in all three spatial dimensions as well as their rotation, that is, yaw, pitch, and roll.

In some cases the data will be explicitly limited to a subset of all the available sensors, most prominently to just one sensor.

Further, we need to convert our sequential data into features that encapsulate temporal changes. For example, one option would be to concatenate a set number of successive data points into one feature, like a [[https://www.geeksforgeeks.org/window-sliding-technique/][sliding window]].

# TODO: why here and not in machine-learning.org?
#   avoid high volatility of datasets in machine-learning.org since
#   models can be sensitive to changes in dataset architecture.

** Labels
The labels we assign to our collected features, represent some kind of typing state. A typing state considers every physical key on a [[https://github.com/davidphilipbarr/Sweep][keyboard]] separately. But what a typing state associates to a key can differ depending on the use case:
- in some cases, we just collect whether keys were changed from an unpressed to a pressed state, (states: =UNCHANGED=, =PRESS=, =RElEASE=)
- in other cases, we collect the state of the keys themselves, that is, whether they are pressed or not. (states: =UNPRESSED=, =PRESSED=)

It is important to note that feature labels are /not necessarily unique/ and labelling should be done with caution to avoid issues arising from feature representation like the following: When using a sliding window and not careful when labelling, a single key press can cause a model recognizing press and release events fire twice. An example for a sliding window with size 5 might look like the following for two consecutive model inputs:
  #+begin_example
  [ 5  4  3  2  1 ] => Prediction: PRESS event
       ^            <- key press event
       
  [ 6  5  4  3  2 ] => Prediction: PRESS event
          ^         <- key press event
  #+end_example

Often, we only consider a subset of all possible key on our [[https://github.com/davidphilipbarr/Sweep][keyboard]], like for example only keys reachable by a certain finger or only one half of the keyboard. The reason for doing so is usually the assumption that the labels can be partitioned in such a way that different models can separately predict events independently from one another. Analogously, for some datasets we leave some features out since we assume that they don't affect the subset of labels we look at.

For some experiments, it could also be interesting to further simplify certain models, e.g. no differentiation between different keys pressed by a key, but these are *not accounted* for in this document since they are usually quick modifications that mostly serve experimental purposes.

* TODO The Data Collection Process

# TODO: python version + package management

** TODO CSV
*** Loading Data
#+header: :noweb-ref csv-helpers
#+begin_src jupyter-python :results silent
  import csv
  import numpy as np

  def load_csv(path, header=True, delimiter=',', parse_fn=lambda x:x):
      with open(path, newline='') as f:
          reader = csv.reader(f, delimiter=delimiter)
          if header:
              headerline = next(reader)
              print(f"Header line: {headerline}")
          data = [[parse_fn(value) for value in row]
                  for row in reader]
      if header:
          return (headerline, np.array(data, dtype=np.float64))
      else:
          return np.array(data, dtype=np.float64)
#+end_src

*** Write Data
#+header: :noweb-ref csv-helpers
#+begin_src jupyter-python :results silent
  def write_csv(path, data, header=None, delimiter=','):
      with open(path, "w", newline='') as f:
          writer = csv.writer(f, delimiter=delimiter, lineterminator='\n')
          if header:
              writer.writerow(header)
          writer.writerows(data)
#+end_src
    
* Collecting Data
This is the main part of this document. In this chapter, the [[*The Data Collection Process][general process]] for collecting data is adapted to our specific needs resulting in the actual datasets.

** TODO Capturing Keypresses Directly from the Keyboard
*WARNING*: For the moment, this chapter /only describes data pertaining quick taps/, explicitly /excluding the handling of hold events/ and as such press and release events.

# TODO: raw data or dataset files?
Dataset files:

*** TODO Description
**** Raw Data
  File: [[file:_datasets/2025-01-15_controlled-taps.csv][2025-01-15_controlled-taps.csv]] (4.6Mb, 151471 lines, semicolon separated)
  
  Data was recorded by [[https://github.com/xjjak/][@xjjak]] on <2025-01-15 Wed> over a time of around 10 minutes using sensor #I [fn::#I refers to the physical label of the used sensor.] with the following calibration offsets ={-6018, 1394, 1385, 66, -86, 35}=. The recorded typing motions only contain *short taps* from the middle finger. During the recording, taps were performed in varying frequencies from different starting positions [fn::The position in which the finger rested before performing the tapping motion.] and the order in which the reachable keys were pressed also varies. To ensure consistency, the controller was reset with a brief waiting period beforehand.

  As a result of the recording methodology, there should only be three + one possible key states:
  - lower row, home row, upper row, as well as
  - no key pressed
  The data represents these in a binary format, i.e., the possible states are 0, 1, 2, and 4. Though, other values are technically possible, these are errors and should if possible (it often is) be fixed before proceeding.

  Similarly, only the data collected from one sensor was included. This especially means that there is no data from the sensor on the back of the hand.

  # TODO: format?
  
**** TODO Dataset
      
*** TODO Keypresses Directly from the Keyboard
# TODO: links to relevant code
# TODO: check for correctness (@xjjak)
To collect keypress data directly from the keyboard, we inject some firmware code into the keyboards firmware, that sends key events to an external controller (the project hardware?) via unused pins on the keyboards microcontroller.

*** Rectify Errors
Before we can recitify errors, we first need to be aware of what errors are. In this case, there are two kind of errors to consider -- we will only handle the latter:
1. *Sensor failure*: Sometimes the firmware fails to read data from the sensor or the data it reads doesn't really make any sense. But these kinds of errors are hard to sensibly rectify. Instead, it is often more reasonable to omit data around the errors or to let the machine learning algorithm handle the errors. For now, we will not handle them.
   # TODO: do we check for them? (ig prob should via histogram)
2. *Key event error*: This error is not a technical error per se but a result of typing inprecision. Sometimes multiple pressed keys are recognised, when only one was actually supposed to be pressed. This is the kind of error we can mostly fix because such a multikey press implies that the intended key is one of the recognised presses and the actual press is at the border of both of them.

The next step would be to find those errors in the raw data and handle them -- if appropriate.

**** Find Errors
First, we need to load the data.

#+begin_src jupyter-python :noweb no-export
  # Load CSV helper functions for loading csv data file.
  <<csv-helpers>>
  path_ct = "_datasets/2025-01-15_controlled-taps.csv"
  header_ct, data_ct = load_csv(path_ct, header=True, delimiter=';', parse_fn=int)
#+end_src

#+RESULTS:
: Header line: ['kb_state', 'ax', 'ay', 'az', 'gx', 'gy', 'gz']

The raw data consists of a list of readings. These however do not include enough context, to detect all erroneous readings and fix the errors. Instead of the readings themselves, we consider /taps/. As a tap, we understand a maximally long sequence of consecutive readings with nonzero keyboard states.

#+begin_src jupyter-python :results silent
  # Get starting (inclusive) and ending (exclusive) index of reading
  # around given reading.
  def get_tap_around(reading_idx, data):
      # check if inside tap
      assert data[reading_idx][0] != 0
      
      i = reading_idx
      while i > 0 and data[i-1][0] != 0:
          i -= 1
      a = i
      while i < len(data) and data[i][0] != 0:
          i += 1
      b = i
      
      return a, b
#+end_src

To check the taps for errors, we first need to extract all taps from the given data.

#+begin_src jupyter-python :results silent
  idx = 0
  taps = list()
  while idx < len(data_ct):
      if data_ct[idx][0] != 0:
          tap = get_tap_around(idx, data_ct)
          taps.append(tap)
          idx = tap[1]
      else:
          idx += 1
#+end_src

Next, we identify the erroneous ones. As outlined in the [[*A Brief Description of Our Data][data description]], the only valid /keyboard states/ (first column in the raw data file) are 0, 1, 2, and 4 -- i.e., 000, 001, 010, and 100 in binary. Invalid keyboard states would consequently be 3 (011), 5 (101), 6 (110), and 7 (111). Thus, all taps that contain any invalid keyboard states are erroneous. A tap is also faulty when it contains multiple valid keyboard states, since one tap should also only hit one key. We write the following function to validate taps.

#+begin_src jupyter-python :results silent
  valid_keyboard_states = [0, 1, 2, 4]
  def is_tap_valid(tap, data):
      return len(set(map(lambda i: data[i][0], range(*tap)))) == 1 \
          and data[tap[0]][0] in valid_keyboard_states
#+end_src

Using the function we can filter for invalid taps.

#+begin_src jupyter-python :exports both
  taps_err = list(filter(lambda tap: not is_tap_valid(tap, data_ct), taps))
  
  # Print overview of all erroneous taps
  print("Erroneous taps:")
  for tap in sorted(taps_err):
      start, end = tap
      states = set()
      for j in range(start, end):
          states.add(data_ct[j][0])
      print(f"  from {tap[0]:6d} to {tap[1]:6d} with states: {', '.join(map(str, states))}")

#+end_src

#+RESULTS:
: Erroneous taps:
:   from  23627 to  23640 with states: 2.0, 4.0, 6.0
:   from  50182 to  50206 with states: 2.0, 6.0
:   from  53462 to  53483 with states: 2.0, 6.0
:   from  62913 to  62926 with states: 2.0, 3.0
:   from 106848 to 106861 with states: 2.0, 6.0
:   from 126434 to 126452 with states: 2.0, 6.0
:   from 134940 to 134956 with states: 2.0, 6.0

**** Fix Errors
To fix these issues, we have to come up with a strategy for reassigning these multiple, possibly invalid states into one state per tap. The strategy we employ works the following way:
- When there is *at least one valid state*, we assign the first valid state to the tap.
- When there is *only one invalid state*, we assign the state to the tap that corresponds to the non-homerow key that is part of the invalid state.
- /Other situations are not covered for now, since we do not encounter them./

#+begin_src jupyter-python :results silent
  reassignments = dict()

  for tap in taps_err:
      start, end = tap
      contains_valid = False
      for i in range(start, end):
          if data_ct[i][0] in valid_keyboard_states:
              assignment = data_ct[i][0]
              contains_valid = True
              break
      if not contains_valid:
          if data_ct[start][0] & 1:
              assignment = 1
          elif data_ct[start][0] & 4:
              assignment = 4
          else:
              assignment = 2

      reassignments[tap] = assignment
#+end_src

Now we need to apply these reassignments. When a tap is assigned to a certain keyboard state, applying that assignment just means to set the keyboard state of every reading in the tap to the assigned state.

#+begin_src jupyter-python :results silent
  for tap, assignment in reassignments.items():
      start, end = tap
      for i in range(start, end):
          data_ct[i][0] = assignment
#+end_src

Lastly, we write the data to an intermediary file.

# FIX: hardcoded value
# TODO: consider dataset folder

#+begin_src jupyter-python :results silent
  write_csv(
      "_datasets/2025-01-15_controlled-taps_fixed.csv",
      data_ct,
      header=header_ct,
      delimiter=';'
  )
#+end_src

*** A Look at the Data
# TODO: Sections from here on onwards should not depend on the previous section having run.

Before we continue to aggregate the data into feature vectors, we want to take a quick look at the data using [[https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.hist.html][histograms with matplotlib]].

#+begin_src jupyter-python :results silent
  import matplotlib.pyplot as plt
  %matplotlib inline
#+end_src

First, we look at the the distribution of keyboard states.

#+header: :file diagrams/2025-01-15_controlled-taps_histogram-keyboard-states.png
#+begin_src jupyter-python :results output :exports both
  unique, counts = np.unique(data_ct[:,0], return_counts=True)
  plt.bar(unique, counts, label=header_ct[0])
  plt.legend(prop={'size': 10})
  plt.title('histogram of keyboard states')
#+end_src

#+RESULTS:
[[file:diagrams/2025-01-15_controlled-taps_histogram-keyboard-states.png]]

As expected, the majority of states are resting states and fortunately the other states seem equally frequent.

Next, we look at the acceleration data.

#+header: :file diagrams/2025-01-15_controlled-taps_histogram-acceleration.png
#+begin_src jupyter-python :results output :exports both
  plt.hist(data_ct[:,1:4], bins=100, density=True, label=header_ct[1:4], histtype='stepfilled')
  plt.legend(prop={'size': 10})
  plt.title('histogram of acceleration data')
#+end_src

#+RESULTS:
[[file:diagrams/2025-01-15_controlled-taps_histogram-acceleration.png]]

The first thing we notice is that the calibration does not seem to work that well but this is something we have come to expect since the absolute values seem to drift unpredictably over time. Apart from that, we also notice that =ax= and =az= seem to be distributed normally with little variation, unlike =ay= which is distributed much more broadly and seemingly also not in a normal distribution. This could indicate, that =ay= could play an important role detecting taps. We also, notably, don't see any significant amount noise which is good.

Lastly, we look at the rotation data.

#+header: :file diagrams/2025-01-15_controlled-taps_histogram-rotation.png
#+begin_src jupyter-python :results output :exports both
  plt.hist(data_ct[:,4:], bins=100, density=True, label=header_ct[4:], histtype='stepfilled')
  plt.legend(prop={'size': 10})
  plt.title('histogram of rotation data')
#+end_src

#+RESULTS:
[[file:diagrams/2025-01-15_controlled-taps_histogram-rotation.png]]

For the rotation data we also fortunately do not observe any significant amount of noise. All rotation axes seem to be normally distributed which we expect since any variation from typing on different keys should be observed equally frequent on both ends. Also, =gx= and =gz= are distributed slightly more broadly than =gy= which might indicate that these are the axes that the finger rotates around while typing.

*** Center the Data
As we saw in [[*A Look at the Data][A Look at the Data]], the sensor calibration is not reasonable reliable over the long term, drifts accumulate over time and calibrating the sensors every time you want to use the device is infeasible. Instead, we want to try dynamic calibration: The first approach that comes to mind is to keep some sort of average that favors more recent data, like a [[https://en.wikipedia.org/wiki/Moving_average][moving average]]. We want to try to use the [[https://en.wikipedia.org/wiki/Exponential_smoothing][exponantial moving average]].

#+begin_src jupyter-python :async yes :results silent
  def center_moving_average(data, alpha=0.995):
      moving_avg = np.zeros_like(data_ct)
      moving_avg[0,:] = data_ct[0,:]
      for i in range(1,len(data_ct)):
          moving_avg[i,:] = alpha*moving_avg[i-1,:] + (1-alpha)*data_ct[i,:]
          
      return data_ct - moving_avg

  data_ct_centered = center_moving_average(data_ct, alpha=0.95)
#+end_src

**** A Visual Comparison to the Uncentered Data
We want the exponential moving average to approximate the real average of the data. The closer we get to that, the more similar the distribution should look to the uncentered distribution. Essentially, the moving average should only act as a global shift as much as possible.

#+name: compare_ema
#+begin_src jupyter-python :results output :exports code :var alpha=0.95 index=2
  data_tmp = center_moving_average(data_ct, alpha=alpha)
  data_mean = np.mean(data_ct, axis=0)
  plt.hist([data_tmp[:,index], (data_ct - data_mean)[:,index]], bins=50, label=[header_ct[index] + " (EMA)", header_ct[index] + " (centered)"], histtype='step', linewidth=2)
  plt.legend(prop={'size': 10})
  plt.title(f'histogram of acceleration data (alpha={alpha})')
#+end_src

Quick comparison of different averaging weights with =index=2=:
- =alpha=0.5=
  #+call: compare_ema[:file diagrams/ema_centering/compare_0-5.png :exports results](alpha=0.5)

  #+RESULTS:
  [[file:diagrams/ema_centering/compare_0-5.png]]
  
- =alpha=0.8=
  #+call: compare_ema[:file diagrams/ema_centering/compare_0-8.png :exports results](alpha=0.8)

  #+RESULTS:
  [[file:diagrams/ema_centering/compare_0-8.png]]
  
- =alpha=0.9=
  #+call: compare_ema[:file diagrams/ema_centering/compare_0-9.png :exports results](alpha=0.9)

  #+RESULTS:
  [[file:diagrams/ema_centering/compare_0-9.png]]
  
- =alpha=0.95=
  #+call: compare_ema[:file diagrams/ema_centering/compare_0-95.png :exports results](alpha=0.95)

  #+RESULTS:
  [[file:diagrams/ema_centering/compare_0-95.png]]
  
- =alpha=0.99=
  #+call: compare_ema[:file diagrams/ema_centering/compare_0-99.png :exports results](alpha=0.99)

  #+RESULTS:
  [[file:diagrams/ema_centering/compare_0-99.png]]
  
- =alpha=0.995=
  #+call: compare_ema[:file diagrams/ema_centering/compare_0-995.png :exports results](alpha=0.995)

  #+RESULTS:
  [[file:diagrams/ema_centering/compare_0-995.png]]
  
- =alpha=1=
  #+call: compare_ema[:file diagrams/ema_centering/compare_1.png :exports results](alpha=1)

  #+RESULTS:
  [[file:diagrams/ema_centering/compare_1.png]]

Since choosing =alpha=1= would just shift the all the data by the first value -- which is not reliable as a measure to center the data -- =alpha=0.995= gets us most similar fit. This also means that every new reading gets about as much weight as it would if we were to center a second worth of readings, since we read about src_jupyter-python{len(data_ct)//(10*60)} {{{results(=252=)}}} readings per second (assuming a recording time of 10 min).

Taking a closer look at all the sensor readings, we get the following comparison.

#+name: compare-center
#+header: :var alpha=0.995 start=15000 end=17000 index=2
#+begin_src jupyter-python :results output :exports code
  center_data = center_moving_average(data_ct, alpha=alpha)
  data_mean = np.mean(data_ct, axis=0)
  fig, axs = plt.subplots(3, 1, sharex=True, height_ratios=(10,10,3))
  axs[0].plot(np.arange(start, end), data_ct[start:end,index], label=header_ct[index])
  axs[0].plot(np.arange(start, end), (data_ct - center_data)[start:end,index], label=header_ct[index] + " (EMA)")
  axs[0].plot([start, end], [data_mean[index], data_mean[index]], label=header_ct[index]+" (mean)")
  axs[1].plot(np.arange(start, end), center_data[start:end,index], label=header_ct[index]+" (centered)")
  axs[2].step(
      np.arange(start, end),
      np.minimum(data_ct[start:end, 0], 3),
      label="taps",
  )
  axs[2].set_ylim([0, 3.5])
  axs[2].set_yticks([0, 1, 2, 3])
  axs[0].legend(prop={'size': 7}, bbox_to_anchor=(1.0, 1.0))
  axs[1].legend(prop={'size': 7}, bbox_to_anchor=(1.0, 1.0))
  axs[2].legend(prop={'size': 7}, bbox_to_anchor=(1.0, 1.0))
#+end_src

For the following comparison we set =alpha=0.995=, =start=10000=, and =end=13000=
- =index=1=:
  #+call: compare-center[:file diagrams/ema_centering/compare-center_1.png :exports results](index=1)

  #+RESULTS:
  [[file:diagrams/ema_centering/compare-center_1.png]]
  
- =index=2=:
  #+call: compare-center[:file diagrams/ema_centering/compare-center_2.png :exports results](index=2)

  #+RESULTS:
  [[file:diagrams/ema_centering/compare-center_2.png]]
   
- =index=3=:
  #+call: compare-center[:file diagrams/ema_centering/compare-center_3.png :exports results](index=3)

  #+RESULTS:
  [[file:diagrams/ema_centering/compare-center_3.png]]
   
- =index=4=:
   #+call: compare-center[:file diagrams/ema_centering/compare-center_4.png :exports results](index=4)

  #+RESULTS:
  [[file:diagrams/ema_centering/compare-center_4.png]]
   
- =index=5=:
  #+call: compare-center[:file diagrams/ema_centering/compare-center_5.png :exports results](index=5)

  #+RESULTS:
  [[file:diagrams/ema_centering/compare-center_5.png]]
   
- =index=6=:
  #+call: compare-center[:file diagrams/ema_centering/compare-center_6.png :exports results](index=6)

  #+RESULTS:
  [[file:diagrams/ema_centering/compare-center_6.png]]

We notice that the average is pretty reliable for the acceleration data, but for the rotation data we see more fluctuations in the average and it is not clear how that might affect learning.

# TODO: should we center rotations?

**** Save Data
The centered data is another intermediary step we want to save.

#+begin_src jupyter-python :results silent
  write_csv(
      "_datasets/2025-01-15_controlled-taps_fixed-centered.csv",
      data_ct_centered,
      header=header_ct,
      delimiter=';'
  )
#+end_src

*** TODO Aggregate Features and Labels
**** TODO Features
Every feature needs to encompass information about the state of the sensor as well as its immediate history. This is necessary to enable the model to detect changes in the sensor readings since two resting positions cannot be reliably differentiated even if one is in the air and the other on the table.

To add history information to our features, we consider two kinds of additional features:
- the *change* of every sensor value compared to its predecessor; if more history is necessary one could also add the *change of the change* and so on. (a form of discrete numerical differentiation)
- the *history* itself, i.e., we just add the previous sensor reading to our feature vector. For more history we can just add more readings.
  
Both approaches have their own set of benefits and drawbacks. We list some here:
- Simpler models might work better on change than on history values.
- Normalization techniques might affect the information in change values since they are dependent on other values in the feature vector. This might not necessarily a problem though, since it might be enough to just compare them in relation to other change values.
  
The conclusion here seems to be, that change values are more suitable for simpler models, especially if they work well without normalization, and that history values are the better choice for more complex models, like neural networks, and strongly benefit from normalization and through their complexity can consider change values implicitly on their own. Thus, we will prepare both datasets for further experimentation.

***** Change-based Features
# TODO: degree as org variable?

Before we can create change-based features, we first need to decide the /degree/, i.e., how many levels of change we include.

#+begin_src jupyter-python :results silent
  N_DEGREE = 5
  N_SENSOR_DIMS = 6
#+end_src

Then, we can create our feature vectors. We assume that higher levels of change can be initialized with zeros for the first few features vectors which corresponds to the absence of sensor movement which should be compatible with the data collection methodology.
# Should the first N_DEGREE be included? Assuming no change seems somewhat reasonable

#+begin_src jupyter-python :results silent
  features_ct_change = np.zeros((len(data_ct), N_DEGREE * N_SENSOR_DIMS))
  for d in range(N_DEGREE):
      features_ct_change[d, 0:N_SENSOR_DIMS] = data_ct[d,1:]

  for i in range(len(data_ct)):
      for d in range(min(N_DEGREE, i+1)):
          if d == 0:
              features_ct_change[i, 0:N_SENSOR_DIMS] = data_ct[i,1:]
          else:
              previous = features_ct_change[i-1, (d-1)*N_SENSOR_DIMS:d*N_SENSOR_DIMS]
              current  = features_ct_change[i, (d-1)*N_SENSOR_DIMS:d*N_SENSOR_DIMS]
              features_ct_change[i, d*N_SENSOR_DIMS:(d+1)*N_SENSOR_DIMS] = current - previous
#+end_src

***** History-based Features
# TODO: degree as org variable?

Similarly to the change-based features, the history-based features also need a degree -- in this case the number of previous readings to include.

#+begin_src jupyter-python :results silent
  N_DEGREE = 5
  N_SENSOR_DIMS = 6
#+end_src

With that, we can create the feature vectors. This time we discard the first =N_DEGREE= of potential feature vectors. Alternatively, we could also duplicate the first reading =N_DEGREE= times to achieve a similar effect to what we did for [[*Change-based Features][change-based feature vectors]].

#+begin_src jupyter-python :results silent
  features_ct_history = np.zeros((len(data_ct)-N_DEGREE, N_DEGREE * N_SENSOR_DIMS))
  for d in range(N_DEGREE):
      features_ct_history[0, d*N_SENSOR_DIMS:(d+1)*N_SENSOR_DIMS] = data_ct[N_DEGREE-d-1,1:]

  for i in range(1, len(data_ct)-N_DEGREE):
      for d in range(N_DEGREE):
          if d == 0:
              features_ct_history[i, 0:N_SENSOR_DIMS] = data_ct[N_DEGREE+i,1:]
          else:
              previous = features_ct_history[i-1, (d-1)*N_SENSOR_DIMS:d*N_SENSOR_DIMS]
              features_ct_history[i, d*N_SENSOR_DIMS:(d+1)*N_SENSOR_DIMS] = previous
#+end_src

**** TODO Labels
*** TODO Write Dataset
