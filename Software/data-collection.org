#+title: Data Collection

#+property: header-args:jupyter-python :session *jupyter* :eval no-export
#+OPTIONS: ^:nil h:6

This document describes all software related to data collection, when possible in a literate programming style.

Except for the [[*A Brief Description of Our Data][first chapter]] -- a broad descrpition of how our data will look for all datasets -- and the [[*The Data Collection Process][second chapter]] -- a description of the general collection process --, the chapters are organized by dataset type. Each dataset type chapter includes all relevant
- descriptions and design choices,
- software to collect the relevant data, and
- processing capabilities to convert raw data into refined datasets.

Notably, the dataset types mostly vary by how we collect the [[*Labels][labels]].

* Contents                                                         :noexport:
:PROPERTIES:
:TOC:      :include all :ignore (this)
:END:

# TOC automattically generated by [[https://github.com/alphapapa/org-make-toc]]
# NOTE: These links will *only* work on github.
:CONTENTS:
- [[#a-brief-description-of-our-data][A Brief Description of Our Data]]
  - [[#features][Features]]
  - [[#labels][Labels]]
- [[#the-data-collection-process][The Data Collection Process]]
  - [[#csv][CSV]]
    - [[#loading-data][Loading Data]]
    - [[#write-data][Write Data]]
- [[#collecting-data][Collecting Data]]
  - [[#capturing-keypresses-directly-from-the-keyboard][Capturing Keypresses Directly from the Keyboard]]
    - [[#description][Description]]
      - [[#raw-data][Raw Data]]
      - [[#dataset][Dataset]]
    - [[#keypresses-directly-from-the-keyboard][Keypresses Directly from the Keyboard]]
    - [[#rectify-errors][Rectify Errors]]
      - [[#find-errors][Find Errors]]
      - [[#fix-errors][Fix Errors]]
    - [[#a-look-at-the-data][A Look at the Data]]
    - [[#aggregate-features-and-labels][Aggregate Features and Labels]]
      - [[#features][Features]]
      - [[#labels][Labels]]
    - [[#write-dataset][Write Dataset]]
:END:

* A Brief Description of Our Data
Before we start describing the software that is used in the data collection process, we first want to give a quick overview of what our data actually consist of and where it comes from.

The data we collect can broadly be divided into two categories, since we use supervised learning:
1. The [[*Features][features]] our model takes as input. These are necessary during training and deployment of the model.
2. The [[*Labels][labels]] our model produces as output. These are only necessary during training. During deployment the model itself will produce predictions for them.

** Features
The features are generated using the hardware developed in [[file:../Hardware][other parts of the project]] in a more or less straightforward. While the specifics might change, in general the data will always come from [[https://en.wikipedia.org/wiki/Inertial_measurement_unit][inertial measurement units]] on the fingers and the back of the hand. The IMUs we currently use (MPU6050) give us information about their current acceleration in all three spatial dimensions as well as their rotation, that is, yaw, pitch, and roll.

In some cases the data will be explicitly limited to a subset of all the available sensors, most prominently to just one sensor.

Further, we need to convert our sequential data into features that encapsulate temporal changes. For example, one option would be to concatenate a set number of successive data points into one feature, like a [[https://www.geeksforgeeks.org/window-sliding-technique/][sliding window]].

# TODO: why here and not in machine-learning.org?
#   avoid high volatility of datasets in machine-learning.org since
#   models can be sensitive to changes in dataset architecture.

** Labels
The labels we assign to our collected features, represent some kind of typing state. A typing state considers every physical key on a [[https://github.com/davidphilipbarr/Sweep][keyboard]] separately. But what a typing state associates to a key can differ depending on the use case:
- in some cases, we just collect whether keys were changed from an unpressed to a pressed state, (states: =UNCHANGED=, =PRESS=, =RElEASE=)
- in other cases, we collect the state of the keys themselves, that is, whether they are pressed or not. (states: =UNPRESSED=, =PRESSED=)

It is important to note that feature labels are /not necessarily unique/ and labelling should be done with caution to avoid issues arising from feature representation like the following: When using a sliding window and not careful when labelling, a single key press can cause a model recognizing press and release events fire twice. An example for a sliding window with size 5 might look like the following for two consecutive model inputs:
  #+begin_example
  [ 5  4  3  2  1 ] => Prediction: PRESS event
       ^            <- key press event
       
  [ 6  5  4  3  2 ] => Prediction: PRESS event
          ^         <- key press event
  #+end_example

Often, we only consider a subset of all possible key on our [[https://github.com/davidphilipbarr/Sweep][keyboard]], like for example only keys reachable by a certain finger or only one half of the keyboard. The reason for doing so is usually the assumption that the labels can be partitioned in such a way that different models can separately predict events independently from one another. Analogously, for some datasets we leave some features out since we assume that they don't affect the subset of labels we look at.

For some experiments, it could also be interesting to further simplify certain models, e.g. no differentiation between different keys pressed by a key, but these are *not accounted* for in this document since they are usually quick modifications that mostly serve experimental purposes.

* TODO The Data Collection Process

# TODO: python version + package management

** TODO CSV
*** Loading Data
#+header: :noweb-ref csv-helpers
#+begin_src jupyter-python :results silent
  import csv
  import numpy as np

  def load_csv(path, header=True, delimiter=',', parse_fn=lambda x:x):
      with open(path, newline='') as f:
          reader = csv.reader(f, delimiter=delimiter)
          if header:
              headerline = next(reader)
              print(f"Header line: {headerline}")
          data = [[parse_fn(value) for value in row]
                  for row in reader]
      if header:
          return (headerline, np.array(data))
      else:
          return np.array(data)
#+end_src

*** Write Data
#+header: :noweb-ref csv-helpers
#+begin_src jupyter-python :results silent
  def write_csv(path, data, header=None, delimiter=','):
      with open(path, "w", newline='') as f:
          writer = csv.writer(f, delimiter=delimiter, lineterminator='\n')
          if header:
              writer.writerow(header)
          writer.writerows(data)
#+end_src
    
* Collecting Data
This is the main part of this document. In this chapter, the [[*The Data Collection Process][general process]] for collecting data is adapted to our specific needs resulting in the actual datasets.

** TODO Capturing Keypresses Directly from the Keyboard
*WARNING*: For the moment, this chapter /only describes data pertaining quick taps/, explicitly /excluding the handling of hold events/ and as such press and release events.

# TODO: raw data or dataset files?
Dataset files:

*** TODO Description
**** Raw Data
  File: [[file:_datasets/2025-01-15_controlled-taps.csv][2025-01-15_controlled-taps.csv]] (4.6Mb, 151471 lines, semicolon separated)
  
  Data was recorded by [[https://github.com/xjjak/][@xjjak]] on <2025-01-15 Wed> over a time of around 10 minutes using sensor #I [fn::#I refers to the physical label of the used sensor.] with the following calibration offsets ={-6018, 1394, 1385, 66, -86, 35}=. The recorded typing motions only contain *short taps* from the middle finger. During the recording, taps were performed in varying frequencies from different starting positions [fn::The position in which the finger rested before performing the tapping motion.] and the order in which the reachable keys were pressed also varies. To ensure consistency, the controller was reset with a brief waiting period beforehand.

  As a result of the recording methodology, there should only be three + one possible key states:
  - lower row, home row, upper row, as well as
  - no key pressed
  The data represents these in a binary format, i.e., the possible states are 0, 1, 2, and 4. Though, other values are technically possible, these are errors and should if possible (it often is) be fixed before proceeding.

  Similarly, only the data collected from one sensor was included. This especially means that there is no data from the sensor on the back of the hand.

  # TODO: format?
  
**** TODO Dataset
      
*** TODO Keypresses Directly from the Keyboard
# TODO: links to relevant code
# TODO: check for correctness (@xjjak)
To collect keypress data directly from the keyboard, we inject some firmware code into the keyboards firmware, that sends key events to an external controller (the project hardware?) via unused pins on the keyboards microcontroller.

*** Rectify Errors
Before we can recitify errors, we first need to be aware of what errors are. In this case, there are two kind of errors to consider -- we will only handle the latter:
1. *Sensor failure*: Sometimes the firmware fails to read data from the sensor or the data it reads doesn't really make any sense. But these kinds of errors are hard to sensibly rectify. Instead, it is often more reasonable to omit data around the errors or to let the machine learning algorithm handle the errors. For now, we will not handle them.
   # TODO: do we check for them? (ig prob should via histogram)
2. *Key event error*: This error is not a technical error per se but a result of typing inprecision. Sometimes multiple pressed keys are recognised, when only one was actually supposed to be pressed. This is the kind of error we can mostly fix because such a multikey press implies that the intended key is one of the recognised presses and the actual press is at the border of both of them.

The next step would be to find those errors in the raw data and handle them -- if appropriate.

**** Find Errors
First, we need to load the data.

#+begin_src jupyter-python :noweb no-export
  # Load CSV helper functions for loading csv data file.
  <<csv-helpers>>
  path_ct = "_datasets/2025-01-15_controlled-taps.csv"
  header_ct, data_ct = load_csv(path_ct, header=True, delimiter=';', parse_fn=int)
#+end_src

#+RESULTS:
: Header line: ['kb_state', 'ax', 'ay', 'az', 'gx', 'gy', 'gz']

The raw data consists of a list of readings. These however do not include enough context, to detect all erroneous readings and fix the errors. Instead of the readings themselves, we instead consider /taps/. As a tap, we understand a maximally long sequence of consecutive readings with nonzero keyboard state.

#+begin_src jupyter-python :results silent
  # Get starting (inclusive) and ending (exclusive) index of reading
  # around given reading.
  def get_tap_around(reading_idx, data):
      # check if inside tap
      assert data[reading_idx][0] != 0
      
      i = reading_idx
      while i > 0 and data[i-1][0] != 0:
          i -= 1
      a = i
      while i < len(data) and data[i][0] != 0:
          i += 1
      b = i
      
      return a, b
#+end_src

To check the taps for errors, we first need to extract all taps from the given data.

#+begin_src jupyter-python :results silent
  idx = 0
  taps = list()
  while idx < len(data_ct):
      if data_ct[idx][0] != 0:
          tap = get_tap_around(idx, data_ct)
          taps.append(tap)
          idx = tap[1]
      else:
          idx += 1
#+end_src

Next, we identify the erroneous ones. As outlined in the [[*A Brief Description of Our Data][data description]], the only valid /keyboard states/ (first column in the raw data file) are 0, 1, 2, and 4 -- i.e., 000, 001, 010, and 100 in binary. Invalid keyboard states would consequently be 3 (011), 5 (101), 6 (110), and 7 (111). Thus, all taps that contain any invalid keyboard states are erroneous. A tap is also faulty when it contains multiple valid keyboard states, since one tap should also only hit one key. We write the following function to validate taps.

#+begin_src jupyter-python :results silent
  def is_tap_valid(tap, data):
      return len(set(map(lambda i: data[i][0], range(*tap)))) == 1 \
          and data[tap[0]][0] in valid_keyboard_states
#+end_src

Using the function we can filter for invalid taps.

#+begin_src jupyter-python
  taps_err = list(filter(lambda tap: not is_tap_valid(tap, data_ct), taps))
  
  # Print overview of all erroneous taps
  print("Erroneous taps:")
  for tap in sorted(taps_err):
      start, end = tap
      states = set()
      for j in range(start, end):
          states.add(data_ct[j][0])
      print(f"  from {tap[0]:6d} to {tap[1]:6d} with states: {', '.join(map(str, states))}")

#+end_src

#+RESULTS:
: Erroneous taps:
:   from  23627 to  23640 with states: 2, 4, 6
:   from  50182 to  50206 with states: 2, 6
:   from  53462 to  53483 with states: 2, 6
:   from  62913 to  62926 with states: 2, 3
:   from 106848 to 106861 with states: 2, 6
:   from 126434 to 126452 with states: 2, 6
:   from 134940 to 134956 with states: 2, 6

**** Fix Errors
To fix these issues, we have to come up with a strategy for reassigning these multiple, possibly invalid states into one state per tap. The strategy we employ works the following way:
- When there is *at least one valid state*, we assign the first valid state to the tap.
- When there is *only one invalid state*, we assign the state to the tap that corresponds to the non-homerow key that is part of the invalid state.
- /Other situations are not covered for now, since we do not encounter them./

#+begin_src jupyter-python :results silent
  reassignments = dict()

  for tap in taps_err:
      start, end = tap
      contains_valid = False
      for i in range(start, end):
          if data_ct[i][0] in valid_keyboard_states:
              assignment = data_ct[i][0]
              contains_valid = True
              break
      if not contains_valid:
          if data_ct[start][0] & 1:
              assignment = 1
          elif data_ct[start][0] & 4:
              assignment = 4
          else:
              assignment = 2

      reassignments[tap] = assignment
#+end_src

Now we need to apply these reassignments. When a tap is assigned to a certain keyboard state, applying that assignment just means to set the keyboard state of every reading in the tap to the assigned state.

#+begin_src jupyter-python :results silent
  for tap, assignment in reassignments.items():
      start, end = tap
      for i in range(start, end):
          data_ct[i][0] = assignment
#+end_src

Lastly, we write the data to an intermediary file.

# FIX: hardcoded value
# TODO: consider dataset folder

#+begin_src jupyter-python :results silent
  write_csv(
      "_datasets/2025-01-15_controlled-taps_fixed.csv",
      data_ct,
      header=header_ct,
      delimiter=';'
  )
#+end_src

*** A Look at the Data
Before we continue to aggregate the data into feature vectors, we want to take a quick look at the data using [[https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.hist.html][histograms with matplotlib]].

#+begin_src jupyter-python
  import matplotlib.pyplot as plt
  %matplotlib inline
#+end_src

First, we look at the the distribution of keyboard states.

#+header: :file diagrams/2025-01-15_controlled-taps_histogram-keyboard-states.png
#+begin_src jupyter-python
  unique, counts = np.unique(data_ct[:,0], return_counts=True)
  plt.bar(unique, counts, label=header_ct[0])
  plt.legend(prop={'size': 10})
  plt.title('histogram of keyboard states')
#+end_src

#+RESULTS:
:RESULTS:
: Text(0.5, 1.0, 'histogram of keyboard states')
[[file:diagrams/2025-01-15_controlled-taps_histogram-keyboard-states.png]]
:END:

As expected, the majority of states are resting states and fortunately the other states seem equally frequent.

Next, we look at the acceleration data.

#+header: :file diagrams/2025-01-15_controlled-taps_histogram-acceleration.png
#+begin_src jupyter-python
  plt.hist(data_ct[:,1:4], bins=100, density=True, stacked=True, label=header_ct[1:4])
  plt.legend(prop={'size': 10})
  plt.title('histogram of acceleration data')
#+end_src

#+RESULTS:
:RESULTS:
: Text(0.5, 1.0, 'histogram of acceleration data')
[[file:diagrams/2025-01-15_controlled-taps_histogram-acceleration.png]]
:END:

The first thing we notice is that the calibration does not seem to work that well but this is something we have come to expect since the absolute values seem to drift unpredictably over time. Apart from that, we also notice that =ax= and =az= seem to be distributed normally with little variation, unlike =ay= which is distributed much more broadly and seemingly also not in a normal distribution. This could indicate, that =ay= could play an important role detecting taps. We also, notably, don't see any significant amount noise which is good.

Lastly, we look at the rotation data.

#+header: :file diagrams/2025-01-15_controlled-taps_histogram-rotation.png
#+begin_src jupyter-python
  plt.hist(data_ct[:,4:], bins=100, density=True, stacked=True, label=header_ct[4:])
  plt.legend(prop={'size': 10})
  plt.title('histogram of rotation data')
#+end_src

#+RESULTS:
:RESULTS:
: Text(0.5, 1.0, 'histogram of rotation data')
[[file:diagrams/2025-01-15_controlled-taps_histogram-rotation.png]]
:END:

For the rotation data we also fortunately do not observe any significant amount of noise. All rotation axes seem to be normally distributed which we expect since any variation from typing on different keys should be observed equally frequent on both ends. Also, =gx= and =gz= are distributed slightly more broadly than =gy= which might indicate that these are the axes that the finger rotates around while typing.

*** TODO Aggregate Features and Labels
**** TODO Features
**** TODO Labels
*** TODO Write Dataset
