#+title: Machine Learning
#+property: header-args:jupyter-python :session *jupyter* :eval no-export :async yes
#+OPTIONS: ^:nil h:6

To LOAD a dataset execute the following code block and select the dataset you want to load.
#+header: :var stage="centered.csv"
#+header: :var dataset=(completing-read "Dataset: " (directory-files "_datasets/" nil directory-files-no-dot-files-regexp) nil t)
#+begin_src jupyter-python :results silent
  import pandas as pd
  import numpy as np
  import matplotlib.pyplot as plt
  from pathlib import Path
  data_dir = Path("_datasets/")
  data_path = data_dir / dataset
  print(f"Loading \"{data_path / stage}\"...\n")
  df = pd.read_csv(data_path / stage)
#+end_src

* Contents                                                         :noexport:
:PROPERTIES:
:TOC:      :include all :ignore (this)
:END:

# TOC automattically generated by [[https://github.com/alphapapa/org-make-toc]]
# NOTE: These links will *only* work on github.
:CONTENTS:
- [[#click-detection][Click Detection]]
  - [[#naive-approach][Naive Approach]]
    - [[#labels][Labels]]
- [[#row-detection][Row detection]]
- [[#column-detection][Column Detection]]
:END:

* Click Detection
* TODO Click Detection
Before we can try to assign every tap a key, we need to first detect such taps. We will try to do so in several ways

** TODO Naive Approach
The first approach we will try, will just use the acceleration data and check whether some threshold is exceeded.

#+begin_src jupyter-python
  df = pd.read_csv(data_path/'centered.csv')
  df.dtypes
#+end_src

#+RESULTS:
: kb_state      int64
: ax          float64
: ay          float64
: az          float64
: gx          float64
: gy          float64
: gz          float64
: dtype: object

But before we do this, we need to be able to check whether our predictions are correct, thus we compile labels from our data in the following way.

#+name: stats
#+begin_src jupyter-python :var n=9
  n = n
  indexers = np.unique(np.concatenate([
      np.arange(max(i-n,0),i+1) for i in df[df.kb_state != 0].index
      if i == 0 or df.kb_state[i-1] == 0
  ]))

  df_tap = df.iloc[indexers]

  print("--- Mean ---")
  print(df_tap.ay.median())
  print("--- Max ---")
  print(df_tap.ay.max())
#+end_src

#+RESULTS: stats
: --- Mean ---
: 1009.7115271248158
: --- Max ---
: 7016.775957891621

A local maximum suggests that n=9 might be a reasonable window before a tap.

#+name: dist
#+begin_src jupyter-python :results output
  neg = 4
  pos = 2

  fig, axs = plt.subplots(neg+pos, 3, sharex=True, sharey=True)

  for x in range(neg+pos):
      for y in range(3):
          n = 3*(x-pos) + y + 1
          indexers = np.array([
              max(i-n, 0) for i in df[df.kb_state != 0].index
              if i == 0 or df.kb_state[i-1] == 0
          ])
      
          if n <= 0:
              col = 'red'
          else:
              col = 'blue'
          axs[x][y].hist(df.iloc[indexers].ay, bins=20, label='ay', color=col)
          axs[x][y].legend(prop={'size': 10}, loc='upper right')
          axs[x][y].axvline(x=df.iloc[indexers].ay.median(), color='green', linewidth=2)
          axs[x][y].text(0.01, 0.99, f'n={-n}', ha='left', va='top', transform=axs[x][y].transAxes)
#+end_src

#+RESULTS: dist
[[file:./.ob-jupyter/bcf6c65a6d421f58ab396c05d4b6728b085daa4d.png]]

It seems like the rise starts a lot earlier potentially. So maybe n=20 is actually more reasonable. Also, we notice that the median approaches 2000 at its peak suggesting that 2000 might be a reasonable threshold.

*** Prediction
The first prediction algorithm is very simple and deterministic and works offline. It just identifies all readings with a y-acceleration greater or equal to some threshold.
#+begin_src jupyter-python :results silent
  def predict_naive(df, threshold=None):
      assert threshold != None

      over = df.ay >= threshold
      return over & ~over.shift(1, fill_value=False)
#+end_src

The second prediction algorithm is very much like the first one but it also requires a down-spike in y-acceleration after an up-spike.
#+begin_src jupyter-python :results silent
  def predict_naive2(df, threshold=None, duration=None):
      assert threshold != None
      assert duration != None

      over = df.ay >= threshold
      candidates = over & ~over.shift(1, fill_value=False)

      valid = df.ay <= -threshold/2
      for i in range(duration):
          valid |= valid.shift(-1, fill_value=False)

      return candidates & valid
#+end_src

*** TODO Scoring
#+name: predict-visual
#+header: :var start=15000 end=17000 threshold=2000
#+begin_src jupyter-python :results output
  fig, axs = plt.subplots(2,1, sharex=True)

  fig.suptitle("Real taps and naive predictions")

  pred = predict_naive(df, threshold=threshold)
  axs[0].step(np.arange(start, end), pred.iloc[start:end], label='prediction')
  axs[0].legend(prop={'size': 10}, loc='upper right')

  axs[1].step(np.arange(start, end), df.iloc[start:end].kb_state != 0, label='tap')
  axs[1].legend(prop={'size': 10}, loc='upper right')
#+end_src

#+RESULTS: predict-visual
[[file:./.ob-jupyter/7e6563370e15c367eeec33dc78e6f7b02140827f.png]]

#+call: predict-visual(threshold=2000)
#+RESULTS:
#+call: predict-visual(threshold=1500)
#+RESULTS:
#+call: predict-visual(threshold=1000)
#+RESULTS:
#+call: predict-visual(threshold=500)
#+RESULTS:
[[file:./.ob-jupyter/7130cee0bdd39d889a3a46ba302a1e5dcebe164d.png]]

To evaluate the performance of the naive classifier, we need to come up with a way to determistically measure the closeness of prediction and reality.

#+begin_src jupyter-python :results silent
  def score_naive(df, prediction, delay=50):
      prediction = prediction
      indices = df[prediction].index

      pos = df.kb_state != 0
      taps = df[pos & ~pos.shift(1, fill_value=False)].index
      pressed = dict([(t, False) for t in taps])

      # Accuracy
      fp = 0
      for (idx, next_idx) in zip(indices, indices[1:]):
          pred_tap = min(len(df), taps[(taps >= idx) & (taps < min(next_idx, idx + delay))].min())
          if pred_tap == len(taps):
              fp += 1
              continue
          elif pred_tap in pressed and not pressed[pred_tap]:
              pressed[pred_tap] = True
          else:
              fp += 1

      tp = sum(pressed.values())
      fn = len(pressed) - tp
      tn = len(df[~(pos & ~pos.shift(1, fill_value=False))])
      

      precision = tp/(fp + tp) if fp + tp != 0 else 0
      recall = tp/(fn + tp) if fp + tp != 0 else 0
      f1 = (2*tp)/(2*tp + fp + fn) if 2*tp + fp + fn != 0 else 0
      
      return {'precision': precision, 'recall': recall, 'f1': f1}
#+end_src

For visualization purposes, we also define a function for producing a plot of the scores that varies exactly one hyperparameter.
#+begin_src jupyter-python :results silent
  def fnplot(xs, fn, scoring = ('precision', 'recall', 'f1')):
      scores_T = [fn(x) for x in xs]
      for scoring_method in scoring:
          scores = [score[scoring_method] for score in scores_T]
          plt.plot(xs, scores, label=scoring_method)
          plt.legend(prop={'size': 10}, loc='upper right')
#+end_src

**** Naive Prediction
#+begin_src jupyter-python :var delay=30 threshold=2000
  score_naive(df, predict_naive(df, threshold=threshold), delay=delay)
#+end_src

#+RESULTS:
| precision | : | 0.3074792243767313 | recall | : | 0.5130970724191063 | f1 | : | 0.384526558891455 |

# TODO: determine tap frequency and density

#+name: delay-graph
#+begin_src jupyter-python :var threshold=2000 :results output
  fnplot(
      np.arange(0, 100),
      (lambda delay: score_naive(df, predict_naive(df, threshold=threshold), delay=delay))
  )
#+end_src

#+RESULTS: delay-graph
[[file:./.ob-jupyter/1f1664ba7ec595499fe41524af09294a96574319.png]]

#+call: delay-graph(threshold=1000)
#+RESULTS:
[[file:./.ob-jupyter/25010fef9245fb10107838d972463f2e420b04fc.png]]

#+call: delay-graph(threshold=500)
#+RESULTS:
[[file:./.ob-jupyter/8c7f1e7a8b1141274bb0b5acaa28fcf104f87a83.png]]

#+name: threshold-graph
#+begin_src jupyter-python :var delay=30 :results output
  fnplot(
      np.linspace(500, 3000, 100),
      lambda threshold: score_naive(df, predict_naive(df, threshold=threshold), delay=delay)
  )
#+end_src

#+RESULTS: threshold-graph
[[file:./.ob-jupyter/491334d61eddbaed9d1276abe0c9a101839b3482.png]]

#+call: threshold-graph(delay=10)
#+RESULTS:
#+call: threshold-graph(delay=20)
#+RESULTS:
#+call: threshold-graph(delay=30)
#+RESULTS:
#+call: threshold-graph(delay=40)
#+RESULTS:
#+call: threshold-graph(delay=50)
#+RESULTS:
#+call: threshold-graph(delay=100)
#+RESULTS:
[[file:./.ob-jupyter/15fc0d37a0f09a4b79527dfc625579928c174ada.png]]

**** Naive Prediction V2
#+name: predict2-visual
#+header: :var start=15000 end=17000 threshold=2000 duration=20
#+begin_src jupyter-python :results output
  fig, axs = plt.subplots(2,1, sharex=True)

  fig.suptitle("Real taps and naive predictions")

  pred = predict_naive2(df, threshold=threshold, duration=duration)
  axs[0].step(np.arange(start, end), pred.iloc[start:end], label='prediction')
  axs[0].legend(prop={'size': 10}, loc='upper right')

  axs[1].step(np.arange(start, end), df.iloc[start:end].kb_state != 0, label='tap')
  axs[1].legend(prop={'size': 10}, loc='upper right')
#+end_src

#+RESULTS: predict2-visual
[[file:./.ob-jupyter/e0f764677ea53725792afc93a28c1198e01c217b.png]]

Interestingly, you can loose some predicted taps when decreasing the threshold because the start of high acceleration phase gets shifted to the right while the start of the low acceleration phase usually does not or at least not as much.

/This is not necessarily the intended behavior but we'll leave it in place for now./

#+call: predict-visual(threshold=2000)
#+RESULTS:
#+call: predict2-visual(threshold=1500)
#+RESULTS:
[[file:./.ob-jupyter/0cd55c1a98df33bca5b11a8b4163d388ca04373c.png]]

Defaults:
# FIX(!): This is a very unstable workaround.
#+name: defaults
#+begin_src jupyter-python :eval no
  threshold=1700
  delay=30
  duration=15
#+end_src

#+begin_src jupyter-python
  score_naive(
      df,
      predict_naive2(df, threshold=threshold, duration=duration),
      delay=delay
  )
#+end_src

#+RESULTS:
| precision | : | 0.3922942206654991 | recall | : | 0.6902927580893683 | f1 | : | 0.5002791736460078 |

# TOOD: Add titles

***** Delay
#+begin_src jupyter-python :noweb no-export :results output
  <<defaults>>
  fnplot(
      np.arange(100),
      lambda delay: score_naive(df, predict_naive2(df, threshold=threshold, duration=duration), delay=delay)
  )
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/309f4df7a02ec587f1fa513ef2c4d12cf2a82650.png]]

***** Threshold
#+begin_src jupyter-python :noweb no-export :results output
  <<defaults>>
  fnplot(
      np.linspace(500, 3000, 100),
      lambda threshold: score_naive(df, predict_naive2(df, threshold=threshold, duration=duration), delay=delay)
  )
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/2adc54607ad3c4a5ba707ee223ea68c72ada9f47.png]]

***** Duration
#+begin_src jupyter-python :noweb no-export :results output
  <<defaults>>
  fnplot(
      np.arange(100),
      lambda duration: score_naive(df, predict_naive2(df, threshold=threshold, duration=duration), delay=delay)
  )
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/e2b5936232edbf95ef28827c39490c150be4136a.png]]


# TODO: make plot matrix?
